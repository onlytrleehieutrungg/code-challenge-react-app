import { Price } from "../types/price";

export const currencies: Price[] = [
  {
    currency: "BLUR",
    date: "2023-08-29T07:10:40.000Z",
    price: 0.20811525423728813,
    imageUrl: "/token-icons/BLUR.svg",
  },
  {
    currency: "bNEO",
    date: "2023-08-29T07:10:50.000Z",
    price: 7.1282679,
    imageUrl: "/token-icons/bNEO.svg",
  },
  {
    currency: "BUSD",
    date: "2023-08-29T07:10:40.000Z",
    price: 0.999183113,
    imageUrl: "/token-icons/BUSD.svg",
  },
  {
    currency: "USD",
    date: "2023-08-29T07:10:30.000Z",
    price: 1,
    imageUrl: "/token-icons/USD.svg",
  },
  {
    currency: "ETH",
    date: "2023-08-29T07:10:52.000Z",
    price: 1645.9337373737374,
    imageUrl: "/token-icons/ETH.svg",
  },
  {
    currency: "GMX",
    date: "2023-08-29T07:10:40.000Z",
    price: 36.345114372881355,
    imageUrl: "/token-icons/GMX.svg",
  },
  {
    currency: "STEVMOS",
    date: "2023-08-29T07:10:40.000Z",
    price: 0.07276706779661017,
    imageUrl: "/token-icons/STEVMOS.svg",
  },
  {
    currency: "LUNA",
    date: "2023-08-29T07:10:40.000Z",
    price: 0.40955638983050846,
    imageUrl: "/token-icons/LUNA.svg",
  },
  {
    currency: "RATOM",
    date: "2023-08-29T07:10:40.000Z",
    price: 10.250918915254237,
    imageUrl: "/token-icons/RATOM.svg",
  },
  {
    currency: "STRD",
    date: "2023-08-29T07:10:40.000Z",
    price: 0.7386553389830508,
    imageUrl: "/token-icons/STRD.svg",
  },
  {
    currency: "EVMOS",
    date: "2023-08-29T07:10:40.000Z",
    price: 0.06246181355932203,
    imageUrl: "/token-icons/EVMOS.svg",
  },
  {
    currency: "IBCX",
    date: "2023-08-29T07:10:40.000Z",
    price: 41.26811355932203,
    imageUrl: "/token-icons/IBCX.svg",
  },
  {
    currency: "IRIS",
    date: "2023-08-29T07:10:40.000Z",
    price: 0.0177095593220339,
    imageUrl: "/token-icons/IRIS.svg",
  },
  {
    currency: "ampLUNA",
    date: "2023-08-29T07:10:40.000Z",
    price: 0.49548589830508477,
    imageUrl: "/token-icons/ampLUNA.svg",
  },
  {
    currency: "KUJI",
    date: "2023-08-29T07:10:45.000Z",
    price: 0.675,
    imageUrl: "/token-icons/KUJI.svg",
  },
  {
    currency: "STOSMO",
    date: "2023-08-29T07:10:45.000Z",
    price: 0.431318,
    imageUrl: "/token-icons/STOSMO.svg",
  },
  {
    currency: "USDC",
    date: "2023-08-29T07:10:40.000Z",
    price: 0.989832,
    imageUrl: "/token-icons/USDC.svg",
  },
  {
    currency: "axlUSDC",
    date: "2023-08-29T07:10:40.000Z",
    price: 0.989832,
    imageUrl: "/token-icons/axlUSDC.svg",
  },
  {
    currency: "ATOM",
    date: "2023-08-29T07:10:50.000Z",
    price: 7.186657333333334,
    imageUrl: "/token-icons/ATOM.svg",
  },
  {
    currency: "STATOM",
    date: "2023-08-29T07:10:45.000Z",
    price: 8.512162050847458,
    imageUrl: "/token-icons/STATOM.svg",
  },
  {
    currency: "OSMO",
    date: "2023-08-29T07:10:50.000Z",
    price: 0.3772974333333333,
    imageUrl: "/token-icons/OSMO.svg",
  },
  {
    currency: "rSWTH",
    date: "2023-08-29T07:10:40.000Z",
    price: 0.00408771,
    imageUrl: "/token-icons/rSWTH.svg",
  },
  {
    currency: "STLUNA",
    date: "2023-08-29T07:10:40.000Z",
    price: 0.44232210169491526,
    imageUrl: "/token-icons/STLUNA.svg",
  },
  {
    currency: "LSI",
    date: "2023-08-29T07:10:50.000Z",
    price: 67.69661525423729,
    imageUrl: "/token-icons/LSI.svg",
  },
  {
    currency: "OKB",
    date: "2023-08-29T07:10:40.000Z",
    price: 42.97562059322034,
    imageUrl: "/token-icons/OKB.svg",
  },
  {
    currency: "OKT",
    date: "2023-08-29T07:10:40.000Z",
    price: 13.561577966101694,
    imageUrl: "/token-icons/OKT.svg",
  },
  {
    currency: "SWTH",
    date: "2023-08-29T07:10:45.000Z",
    price: 0.004039850455012084,
    imageUrl: "/token-icons/SWTH.svg",
  },
  {
    currency: "USC",
    date: "2023-08-29T07:10:40.000Z",
    price: 0.994,
    imageUrl: "/token-icons/USC.svg",
  },
  {
    currency: "WBTC",
    date: "2023-08-29T07:10:52.000Z",
    price: 26002.82202020202,
    imageUrl: "/token-icons/WBTC.svg",
  },
  {
    currency: "wstETH",
    date: "2023-08-29T07:10:40.000Z",
    price: 1872.2579742372882,
    imageUrl: "/token-icons/wstETH.svg",
  },
  {
    currency: "YieldUSD",
    date: "2023-08-29T07:10:40.000Z",
    price: 1.0290847966101695,
    imageUrl: "/token-icons/YieldUSD.svg",
  },
  {
    currency: "ZIL",
    date: "2023-08-29T07:10:50.000Z",
    price: 0.01651813559322034,
    imageUrl: "/token-icons/ZIL.svg",
  },
];

export const beforeCode = `interface WalletBalance {
  currency: string;
  amount: number;
}
interface FormattedWalletBalance {
  currency: string;
  amount: number;
  formatted: string;
}

interface Props extends BoxProps {

}
const WalletPage: React.FC<Props> = (props: Props) => {
  const { children, ...rest } = props;
  const balances = useWalletBalances();
  const prices = usePrices();

	const getPriority = (blockchain: any): number => {
	  switch (blockchain) {
	    case 'Osmosis':
	      return 100
	    case 'Ethereum':
	      return 50
	    case 'Arbitrum':
	      return 30
	    case 'Zilliqa':
	      return 20
	    case 'Neo':
	      return 20
	    default:
	      return -99
	  }
	}

  const sortedBalances = useMemo(() => {
    return balances.filter((balance: WalletBalance) => {
		  const balancePriority = getPriority(balance.blockchain);
		  if (lhsPriority > -99) {
		     if (balance.amount <= 0) {
		       return true;
		     }
		  }
		  return false
		}).sort((lhs: WalletBalance, rhs: WalletBalance) => {
			const leftPriority = getPriority(lhs.blockchain);
		  const rightPriority = getPriority(rhs.blockchain);
		  if (leftPriority > rightPriority) {
		    return -1;
		  } else if (rightPriority > leftPriority) {
		    return 1;
		  }
    });
  }, [balances, prices]);

  const formattedBalances = sortedBalances.map((balance: WalletBalance) => {
    return {
      ...balance,
      formatted: balance.amount.toFixed()
    }
  })

  const rows = sortedBalances.map((balance: FormattedWalletBalance, index: number) => {
    const usdValue = prices[balance.currency] * balance.amount;
    return (
      <WalletRow 
        className={classes.row}
        key={index}
        amount={balance.amount}
        usdValue={usdValue}
        formattedAmount={balance.formatted}
      />
    )
  })

  return (
    <div {...rest}>
      {rows}
    </div>
  )
}`;

export const afterCode = `interface WalletBalance {
  currency: string;
  amount: number;
  blockchain: string; // Added blockchain property
}

interface Props extends BoxProps {}

const priorities: Record<string, number> = {
  Osmosis: 100,
  Ethereum: 50,
  Arbitrum: 30,
  Zilliqa: 20,
  Neo: 20,
};

const WalletPage: React.FC<Props> = (props: Props) => {
  const { children, ...rest } = props;
  const balances = useWalletBalances(); // Assuming useWalletBalances is a custom hook
  const prices = usePrices(); // Assuming usePrices is a custom hook

  const getPriority = (blockchain: string): number => priorities[blockchain] || -99;

  const sortedBalances = useMemo(() => {
    return balances
      .filter((balance: WalletBalance) => balance.amount <= 0)
      .sort((lhs: WalletBalance, rhs: WalletBalance) => getPriority(rhs.blockchain) - getPriority(lhs.blockchain));
  }, [balances]);

  const rows = useMemo(() =>
    sortedBalances.map((balance: WalletBalance, index: number) => {
      const usdValue = prices[balance.currency] * balance.amount;
      const formattedAmount = balance.amount.toFixed();
      return (
        <WalletRow
          className={classes.row} // Assuming classes.row is defined
          key={index}
          amount={balance.amount}
          usdValue={usdValue}
          formattedAmount={formattedAmount}
        />
      );
    }),
    [sortedBalances, prices]
  );

  return <div {...rest}>{rows}</div>;
};

export default WalletPage;`;

export const beforeText = `Issues Found:

Inefficient Sorting and Filtering
- Filtering Logic: The filtering function in useMemo checks lhsPriority instead of balancePriority, leading to potential errors.
- Sorting Logic: The sorting function redundantly compares blockchain priorities twice (leftPriority and rightPriority).

Redundant Mapping: Both sortedBalances and formattedBalances duplicate the mapping and formatting operations (map followed by toFixed()).

Suboptimal Price Calculation: usdValue is calculated inside the rows mapping function, which could be inefficient if prices is large or if re-renders are frequent.

Non-Optimal Switch Statement: getPriority uses a switch statement for priorities, which could be improved using a lookup object for better scalability.`;

export const afterText = `Improvements Made:

Simplified the sorting logic to directly use getPriority for comparisons.

Combined mapping and formatting operations into a single useMemo call for rows.

Moved usdValue calculation into useMemo to optimize performance.

Replaced the switch statement in getPriority with a lookup object (priorities) for clearer and more scalable priority assignment.`;
